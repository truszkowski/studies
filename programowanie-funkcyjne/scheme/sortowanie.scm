; *1 - selection-sort
(define (selection-sort l) (getall*1 '() (putall*1 empty l)))
(define (putall*1 q l)
  (if (null? l)
      q
      (putall*1 (put*1 q (car l)) (cdr l))))
(define (getall*1 l q)
  (if (empty? q)
      l
      (let ((gm (getmax*1 q)))
        (getall*1 (cons (car gm) l) (cdr gm)))))
(define (put*1 k x) (cons x k))
(define (getmax*1 l)
  (if (null? l)
      (error "kolejka pusta")
      (get*1 (car l) '() (cdr l))))
(define (get*1 a r l)
  (if (null? l)
      (cons a r)
      (if (> a (car l))
          (get*1 a (cons (car l) r) (cdr l))
          (get*1 (car l) (cons a r) (cdr l)))))

; *2 - invertion
(define (invertion-sort l) (getall*2 '() (putall*2 empty l)))
(define (putall*2 q l)
  (if (null? l)
      q
      (putall*2 (put*2 q (car l)) (cdr l))))
(define (getall*2 l q)
  (if (empty? q)
      l
      (let ((gm (getmax*2 q)))
        (getall*2 (cons (car gm) l) (cdr gm)))))
(define (getmax*2 k) k)
(define (put*2 q x)
  (cond ((null? q) (list x))
        ((>= x (car q)) (cons x q))
        (else (cons (car q) (put*2 (cdr q) x)))))

; *3 - heap
(define (heap-sort l) (getall*3 '() (putall*3 empty l)))
(define (putall*3 q l)
  (if (null? l)
      q
      (putall*3 (put*3 q (car l)) (cdr l))))
(define (getall*3 l q)
  (if (empty? q)
      l
      (let ((gm (getmax*3 q)))
        (getall*3 (cons (car gm) l) (cdr gm)))))
(define root car)
(define (size h)
  (if (null? h)
      0
      (cadr h)))
(define left caddr)
(define right cadddr)
(define (heap v l r)
  (list v (+ (size l) (size r) 1) l r))
(define (put*3 h x)
  (cond ((empty? h) (heap x empty empty))
        ((< (size (left h)) (size (right h))) (heap (max x (root h)) (put*3 (left h) (min x (root h))) (right h)))
        (else (heap (max x (root h)) (left h) (put*3 (right h) (min x (root h)))))))
(define (getmax*3 h)
  (cond ((empty? h) (error "pusta kolejka"))
        ((empty? (left h)) (cons (root h) (right h)))
        ((empty? (right h)) (cons (root h) (left h)))
        ((>= (root (left h)) (root (right h)))
         (let ((maxleft (getmax*3 (left h))))
           (cons (root h) (heap (car maxleft) (cdr maxleft) (right h)))))
        (else (let ((maxright (getmax*3 (right h))))
                (cons (root h) (heap (car maxright) (left h) (cdr maxright)))))))